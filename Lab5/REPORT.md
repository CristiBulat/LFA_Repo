# Topic: Chomsky Normal Form

### **Course:** Formal Languages & Finite Automata
### **Author:** Bulat Cristian

## Theory

### Chomsky Normal Form (CNF)

A context-free grammar is in **Chomsky Normal Form** if all its production rules satisfy one of the following conditions:

1. A → BC, where B and C are non-terminal symbols
2. A → a, where a is a terminal symbol
3. S → ε, where S is the start symbol and S does not appear on the right side of any rule

CNF is particularly important in computational linguistics and formal language theory because:
- It simplifies parsing algorithms
- It's used in the CYK (Cocke-Younger-Kasami) algorithm for parsing
- It provides a standardized form for analyzing context-free grammars

### Converting to Chomsky Normal Form

To convert a context-free grammar to CNF, the following steps are performed:

1. **Eliminate ε-productions**: Remove rules that produce the empty string (ε) and adjust other rules to compensate.
2. **Eliminate unit productions (renaming)**: Remove rules of the form A → B where B is a non-terminal.
3. **Eliminate inaccessible symbols**: Remove symbols that cannot be reached from the start symbol.
4. **Eliminate non-productive symbols**: Remove symbols that cannot derive a string of terminals.
5. **Convert to CNF form**: Ensure all remaining productions have either the form A → BC or A → a.

## Objectives

1. Learn about Chomsky Normal Form (CNF) and its significance.
2. Understand the step-by-step process of converting a grammar to CNF.
3. Implement a comprehensive method for normalizing an input grammar by the rules of CNF.
4. Test the implementation with the variant grammar and demonstrate it works with any grammar.
5. Understand the theoretical implications of the CNF transformation.

## Implementation Description

The implementation consists of a Grammar class with methods for each of the CNF conversion steps, and a Main class to test the implementation with different grammars.

### Grammar Class Structure

The Grammar class represents a formal grammar with components:
- Set of non-terminal symbols
- Set of terminal symbols
- Production rules as a map from non-terminals to lists of strings
- Start symbol

```java
public class Grammar {
    private Set<String> nonTerminals;
    private Set<String> terminals;
    private Map<String, List<String>> productions;
    private String startSymbol;
    
    // Constructor and methods
}
```

### Step 1: Eliminating ε-productions

The `eliminateEpsilonProductions()` method implements a systematic approach to removing ε-productions while preserving the language generated by the grammar. The implementation follows these key steps:

First, it identifies all nullable symbols (non-terminals that can derive ε) through multiple passes over the grammar. It starts by finding directly nullable symbols (those with explicit ε-productions) and then iteratively finds indirectly nullable symbols (those that can derive a string of nullable symbols).

```java
private Set<String> findNullableSymbols() {
    Set<String> nullableSymbols = new HashSet<>();
    
    // First find direct nullable symbols
    for (String nonTerminal : productions.keySet()) {
        for (String rule : productions.get(nonTerminal)) {
            if (rule.isEmpty()) {
                nullableSymbols.add(nonTerminal);
                break;
            }
        }
    }
    
    // Find indirect nullable symbols iteratively
    boolean changed;
    do {
        changed = false;
        // Check if more symbols can be marked as nullable
        // ...
    } while (changed);
    
    return nullableSymbols;
}
```

After identifying nullable symbols, the method generates new productions by systematically creating combinations where nullable symbols are optionally removed. For each production rule containing nullable symbols, it generates all possible variants where one or more nullable symbols are omitted.

```java
// Generate new productions considering nullable symbols
for (String nonTerminal : productions.keySet()) {
    // Generate combinations by removing nullable symbols
    // ...
}
```

### Step 2: Eliminating Unit Productions

The `eliminateUnitProductions()` method removes unit productions (rules of the form A → B where B is a non-terminal) while preserving the language generated by the grammar. This step is critical for the CNF requirement that right-hand sides must be either a single terminal or multiple non-terminals.

The implementation first identifies all unit pairs (A,B) where A can derive B through a series of unit productions. It uses a transitive closure algorithm to find all such pairs:

```java
private Map<String, Set<String>> findUnitPairs() {
    Map<String, Set<String>> unitPairs = new HashMap<>();
    
    // Initialize with identity pairs (A,A)
    for (String nonTerminal : nonTerminals) {
        Set<String> pairs = new HashSet<>();
        pairs.add(nonTerminal);
        unitPairs.put(nonTerminal, pairs);
    }
    
    // Find unit pairs iteratively
    boolean changed;
    do {
        changed = false;
        // Expand unit pairs based on current productions
        // ...
    } while (changed);
    
    return unitPairs;
}
```

Then, it creates new production rules by replacing each unit production A → B with the set of non-unit productions B → γ, effectively bypassing the unit production while preserving the language.

```java
// For each non-terminal, add non-unit productions based on unit pairs
for (String A : nonTerminals) {
    Set<String> unitReachable = unitPairs.getOrDefault(A, new HashSet<>());
    
    for (String B : unitReachable) {
        // For each non-unit production of B, add it to A
        // ...
    }
}
```

### Step 3: Eliminating Inaccessible Symbols

The `eliminateInaccessibleSymbols()` method removes all symbols that cannot be reached from the start symbol using a breadth-first search algorithm. This step ensures that the grammar doesn't contain superfluous symbols that don't contribute to the language.

```java
private Set<String> findAccessibleSymbols() {
    Set<String> accessibleSymbols = new HashSet<>();
    Queue<String> queue = new LinkedList<>();
    
    // Start with the start symbol
    queue.add(startSymbol);
    accessibleSymbols.add(startSymbol);
    
    // BFS to find all accessible symbols
    while (!queue.isEmpty()) {
        String current = queue.poll();
        
        // If current is a non-terminal, process its productions
        if (nonTerminals.contains(current)) {
            // Find all symbols in the productions and add them to the queue
            // ...
        }
    }
    
    return accessibleSymbols;
}
```

After identifying accessible symbols, the method updates the grammar by removing all inaccessible symbols and their associated productions.

### Step 4: Eliminating Non-productive Symbols

The `eliminateNonProductiveSymbols()` method removes symbols that cannot derive a string of terminals. A non-terminal is productive if it can be replaced by a string of terminals through a series of production rules.

```java
private Set<String> findProductiveSymbols() {
    Set<String> productiveSymbols = new HashSet<>();
    
    // First pass: non-terminals with productions containing only terminals
    for (String nonTerminal : nonTerminals) {
        // Check if any production has only terminals
        // ...
    }
    
    // Iteratively find more productive non-terminals
    boolean changed;
    do {
        changed = false;
        // Check if more symbols can be marked as productive
        // ...
    } while (changed);
    
    return productiveSymbols;
}
```

After identifying productive symbols, the method updates the grammar by removing all non-productive symbols and their associated productions, as well as any productions that contain non-productive symbols.

### Step 5: Converting to CNF Form

The final step, implemented in `convertToChomskyNormalForm()`, ensures all productions have either the form A → BC (where B and C are non-terminals) or A → a (where a is a terminal). This step has two major parts:

1. Replace terminals in mixed productions with new non-terminals:
```java
private void replaceTerminalsInMixedProductions() {
    // For each terminal, create a new non-terminal
    for (String terminal : terminals) {
        String newNonTerminal = "X_" + terminal;
        // Add new production: X_a → a
        // ...
    }
    
    // Replace terminals in mixed productions
    // ...
}
```

2. Break productions with more than two non-terminals:
```java
private void breakLongProductions() {
    // Iteratively replace A → X1X2...Xn with A → X1Y, Y → X2...Xn
    do {
        // Find and replace long productions
        // ...
    } while (madeChanges);
}
```

### Integration and Testing

The complete CNF conversion process is orchestrated by the `convertToCNF()` method, which applies all five steps in sequence:

```java
public void convertToCNF() {
    // Step 1: Eliminate ε-productions
    eliminateEpsilonProductions();
    
    // Step 2: Eliminate unit productions
    eliminateUnitProductions();
    
    // Step 3: Eliminate inaccessible symbols
    eliminateInaccessibleSymbols();
    
    // Step 4: Eliminate non-productive symbols
    eliminateNonProductiveSymbols();
    
    // Step 5: Convert to Chomsky Normal Form
    convertToChomskyNormalForm();
}
```

In the Main class, the implementation is tested with both the variant grammar and a custom grammar to demonstrate its flexibility.

## Results

### Variant 5 Grammar

The original grammar from Variant 5 is:
```
G = (VN, VT, P, S)
VN = {S, A, B, C, D}
VT = {a, b, d}
P = {
  1. S → dB
  2. S → A
  3. A → d
  4. A → dS
  5. A → aBdB
  6. B → a
  7. B → aS
  8. B → AC
  9. D → AB
  10. C → bC
  11. C → ε
}
```

After applying the CNF conversion process, we get the following steps:

1. **After eliminating ε-productions**:
```
G = (VN, VT, P, S)
VN = [A, B, C, D, S]
VT = [a, b, d]
S = S
P = {
  1. S → dB
  2. S → A
  3. A → d
  4. A → dS
  5. A → aBdB
  6. B → a
  7. B → aS
  8. B → A
  9. B → AC
  10. D → AB
  11. C → bC
  12. C → b
}
```

2. **After eliminating unit productions**:
```
G = (VN, VT, P, S)
VN = [A, B, C, D, S]
VT = [a, b, d]
S = S
P = {
  1. S → dB
  2. S → d
  3. S → dS
  4. S → aBdB
  5. A → d
  6. A → dS
  7. A → aBdB
  8. B → a
  9. B → aS
  10. B → d
  11. B → dS
  12. B → aBdB
  13. B → AC
  14. D → AB
  15. C → bC
  16. C → b
}
```

3. **After eliminating inaccessible symbols**:
```
G = (VN, VT, P, S)
VN = [A, B, C, S]
VT = [a, b, d]
S = S
P = {
  1. S → dB
  2. S → d
  3. S → dS
  4. S → aBdB
  5. A → d
  6. A → dS
  7. A → aBdB
  8. B → a
  9. B → aS
  10. B → d
  11. B → dS
  12. B → aBdB
  13. B → AC
  14. C → bC
  15. C → b
}
```

4. **After eliminating non-productive symbols**:
   The grammar is already productive, so there are no changes.

5. **Final Chomsky Normal Form**:
```
G = (VN, VT, P, S)
VN = [A, B, C, S, X_a, X_b, X_d, Y1, Y2, Y3, Y4]
VT = [a, b, d]
S = S
P = {
  1. S → X_dB
  2. S → X_d
  3. S → X_dS
  4. S → X_aY1
  5. A → X_d
  6. A → X_dS
  7. A → X_aY2
  8. B → X_a
  9. B → X_aS
  10. B → X_d
  11. B → X_dS
  12. B → X_aY3
  13. B → AC
  14. C → X_bC
  15. C → X_b
  16. X_a → a
  17. X_b → b
  18. X_d → d
  19. Y1 → Y4Y3
  20. Y2 → Y4Y3
  21. Y3 → Y4Y3
  22. Y4 → X_dB
}
```

### Bonus Custom Grammar

The implementation also successfully converts a custom grammar to CNF, demonstrating its flexibility to work with any context-free grammar.

## Conclusion

In this laboratory work, I successfully implemented a comprehensive method for converting a context-free grammar to Chomsky Normal Form. The implementation follows the standard five-step process for CNF conversion: eliminating ε-productions, eliminating unit productions, eliminating inaccessible symbols, eliminating non-productive symbols, and finally converting to the standard CNF form.

Key achievements of this laboratory work include:

1. **Theoretical Understanding**: Gained a deeper understanding of context-free grammars and the significance of normal forms in formal language theory.

2. **Algorithm Implementation**: Successfully implemented complex algorithms for grammar transformation, including:
    - Finding nullable, accessible, and productive symbols
    - Generating combinations with nullable symbols removed
    - Computing transitive closures for unit production elimination
    - Breadth-first search for accessibility analysis
    - Fixed-point algorithms for productive symbol identification

3. **Software Engineering Skills**: Applied good software engineering practices:
    - Modular design with clear separation of concerns
    - Comprehensive documentation
    - Clean, readable code
    - Appropriate data structures for efficient operations

4. **Verification and Testing**: Tested the implementation with both the variant grammar and a custom grammar, verifying that each step produces the expected results.

5. **Practical Application**: The implemented CNF converter has practical applications in parsing and language recognition, particularly for implementing the CYK parsing algorithm.

The successful completion of this laboratory work demonstrates a solid understanding of formal language theory and the ability to implement complex algorithms for grammar transformation.

## References

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, and Computation.
2. Sipser, M. (2012). Introduction to the Theory of Computation.
3. Chomsky, N. (1959). On certain formal properties of grammars. Information and Control, 2(2), 137-167.
4. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools.
5. Formal Languages & Finite Automata course materials.